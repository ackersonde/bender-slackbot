package commands

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/nlopes/slack"
)

var raspberryPIIP = os.Getenv("raspberryPIIP")
var rtm *slack.RTM
var piSDCardPath = "/home/pi/torrents/"
var piUSBMountPath = "/mnt/usb_1/DLNA/torrents/"
var routerIP = "192.168.1.1"
var tranc = "tranc"

// SlackReportChannel default reporting channel for bot crons
var SlackReportChannel = os.Getenv("slackReportChannel") // C33QYV3PW is #remote_network_report

// SetRTM sets singleton
func SetRTM(rtmPassed *slack.RTM) {
	rtm = rtmPassed
}

// CheckCommand is now commented
func CheckCommand(api *slack.Client, slackMessage slack.Msg, command string) {
	args := strings.Fields(command)
	callingUserProfile, _ := api.GetUserInfo(slackMessage.User)
	params := slack.PostMessageParameters{AsUser: true}

	if args[0] == "yt" {
		if len(args) > 1 {
			// strip '<>' off url
			downloadURL := strings.Trim(args[1], "<>")
			uri, err := url.ParseRequestURI(downloadURL)
			if err != nil {
				api.PostMessage(slackMessage.Channel, "Invalid URL for downloading! ("+err.Error()+")", params)
			} else {
				downloadYoutubeVideo(uri.String())
				api.PostMessage(slackMessage.Channel, "Requested YouTube video...", params)
			}
		} else {
			api.PostMessage(slackMessage.Channel, "Please provide YouTube video URL!", params)
		}
	} else if args[0] == "bb" {
		// TODO pass yesterday's date
		response := ShowBaseBallGames()
		result := "Ball games from " + response.ReadableDate + ":\n"

		for _, gameMetaData := range response.Games {
			watchURL := "<" + gameMetaData[10] + "|" + gameMetaData[0] + " @ " + gameMetaData[4] + ">    "
			downloadURL := "<https://ackerson.de/bb_download?fileType=bb&gameTitle=" + gameMetaData[2] + "-" + gameMetaData[6] + "__" + response.ReadableDate + "&gameURL=" + gameMetaData[10] + " | :smartphone:>"

			result += watchURL + downloadURL + "\n"
		}

		api.PostMessage(slackMessage.Channel, result, params)
	} else if args[0] == "algo" {
		response := ListDODroplets(true)
		if strings.Contains(response, "york.shire") {
			response = "Found AlgoVPN instance `york.shire`."
			// TODO: provide IP address, password and
			// URLs to download sswan & mobileconfig files
			// maybe `docker logs algo_vpn` ?
		} else {
			// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
			doAlgoCircleCIURL := "https://circleci.com/api/v1.1/project/github/danackerson/do-algo?circle-token=" + os.Getenv("circleAPIToken")
			req, _ := http.NewRequest("GET", doAlgoCircleCIURL, nil)
			req.Header.Set("Accept", "application/json")

			resp, err := http.DefaultClient.Do(req)
			if err != nil {
				log.Println("Failed to call CircleCI build for do-algo: ", err)
			}
			defer resp.Body.Close()
			/* TODO: POLL every minute for up to 15mins
			// monitor this OR deploy.ackerson.de for successful finish
			// then ` docker logs --tail 13 algo_vpn | sed -n -e '1,3p'` looking for bottom 13 lines
			        "    \"#                The p12 and SSH keys password for new users is 03342cb3       #\"\n",
			        "    \"#                  The CA key password is 2fd428350ad528ab427728a02ac9500a     #\"\n",
			        "    \"#      Shell access: ssh -i configs/algo.pem root@165.227.71.180        #\"\n"*/

			// TODO: get build num and then POLL it every minute up to 15 mins for SUCCESS or FAIL
			contentBytes, _ := ioutil.ReadAll(resp.Body)
			contentString := string(contentBytes)
			//fmt.Printf("-----------------------------------\n%s\n-----------------------------------\n", contentString)

			var data []map[string]interface{}
			err2 := json.Unmarshal([]byte(contentString), &data)
			if err2 != nil {
				fmt.Printf("-----------------------------------\n%s\n-----------------------------------\n", err2.Error())
			}

			var buildNum = strconv.FormatFloat(data[0]["build_num"].(float64), 'f', -1, 64)
			response = ":circleci: <https://circleci.com/gh/danackerson/do-algo/" + buildNum + "|do-algo Build " + buildNum + ">"
		}
		api.PostMessage(slackMessage.Channel, response, params)
	} else if args[0] == "do" {
		response := ListDODroplets(true)
		api.PostMessage(slackMessage.Channel, response, params)
	} else if args[0] == "dd" {
		if len(args) > 1 {
			number, err := strconv.Atoi(args[1])
			if err != nil {
				api.PostMessage(slackMessage.Channel, "Invalid integer value for ID!", params)
			} else {
				result := DeleteDODroplet(number)
				api.PostMessage(slackMessage.Channel, result, params)
			}
		} else {
			api.PostMessage(slackMessage.Channel, "Please provide Droplet ID from `do` cmd!", params)
		}
	} else if args[0] == "fsck" {
		if runningFritzboxTunnel() {
			response := ""

			if len(args) > 1 {
				path := strings.Join(args[1:], " ")
				response += CheckPiDiskSpace(path)
			} else {
				response += CheckPiDiskSpace("")
			}

			rtm.SendMessage(rtm.NewOutgoingMessage(response, slackMessage.Channel))
		}
	} else if args[0] == "mv" || args[0] == "rm" {
		response := ""
		if len(args) > 1 {
			if runningFritzboxTunnel() {
				path := strings.Join(args[1:], " ")
				if args[0] == "rm" {
					response = DeleteTorrentFile(path)
				} else {
					MoveTorrentFile(path)
				}

				rtm.SendMessage(rtm.NewOutgoingMessage(response, slackMessage.Channel))
			}
		} else {
			rtm.SendMessage(rtm.NewOutgoingMessage("Please provide a filename", slackMessage.Channel))
		}
	} else if args[0] == "torq" {
		var response string
		cat := 0
		if len(args) > 1 {
			if args[1] == "nfl" {
				cat = 200
			} else if args[1] == "ubuntu" {
				cat = 300
			}

			searchString := strings.Join(args, " ")
			searchString = strings.TrimLeft(searchString, "torq")
			fmt.Println("searching for: " + searchString)
			_, response = SearchFor(searchString, Category(cat))
		} else {
			_, response = SearchFor("", Category(cat))
		}
		api.PostMessage(slackMessage.Channel, response, params)
	} else if args[0] == "ovpn" {
		response := RaspberryPIPrivateTunnelChecks(true)
		rtm.SendMessage(rtm.NewOutgoingMessage(response, slackMessage.Channel))
	} else if args[0] == "sw" {
		response := ":partly_sunny_rain: <https://www.wunderground.com/cgi-bin/findweather/getForecast?query=" +
			"48.3,11.35#forecast-graph|10-day forecast Schwabhausen>"
		api.PostMessage(slackMessage.Channel, response, params)
	} else if args[0] == "vpnc" {
		result := vpnTunnelCmds("/usr/sbin/vpnc-connect", "fritzbox")
		rtm.SendMessage(rtm.NewOutgoingMessage(result, slackMessage.Channel))
	} else if args[0] == "vpnd" {
		result := vpnTunnelCmds("/usr/sbin/vpnc-disconnect")
		rtm.SendMessage(rtm.NewOutgoingMessage(result, slackMessage.Channel))
	} else if args[0] == "vpns" {
		result := vpnTunnelCmds("status")
		rtm.SendMessage(rtm.NewOutgoingMessage(result, slackMessage.Channel))
	} else if args[0] == "trans" || args[0] == "trand" || args[0] == tranc {
		if runningFritzboxTunnel() {
			response := torrentCommand(args)
			rtm.SendMessage(rtm.NewOutgoingMessage(response, slackMessage.Channel))
		}
	} else if args[0] == "mvv" {
		response := "<https://img.srv2.de/customer/sbahnMuenchen/newsticker/newsticker.html|Aktuelles>"

		if len(args) > 1 {
			if args[1] == "m" {
				// show next train to MUC
				response = "<" + mvvRoute("Schwabhausen", "München, Hauptbahnhof") + "|going to MUC>"
			} else if args[1] == "s" {
				// show next train to SCHWAB
				response = "<" + mvvRoute("München, Hauptbahnhof", "Schwabhausen") + "|going home>"
			}
		}

		api.PostMessage(slackMessage.Channel, response, params)
	} else if args[0] == "help" {
		response := ":sun_behind_rain_cloud: `sw`: Schwabhausen weather\n" +
			":metro: `mvv (s|m)`: no args->show status, `s`->come home, `m`->goto MUC\n" +
			":closed_lock_with_key: `vpn[c|s|d]`: [C]onnect, [S]tatus, [D]rop VPN tunnel to Fritz!Box\n" +
			":openvpn: `ovpn`: show status of OVPN.se on :raspberry_pi:\n" +
			":algovpn: `algo`: show|launch AlgoVPN droplet on :do_droplet:\n" +
			":do_droplet: `do|dd <id>`: show|delete DigitalOcean droplet(s)\n" +
			":pirate_bay: `torq <search term>`\n" +
			":transmission: `tran[c|s|d]`: [C]reate <URL>, [S]tatus, [D]elete <ID> torrents on :raspberry_pi:\n" +
			":recycle: `rm(|mv) <filename>` from :raspberry_pi: (to `" + piUSBMountPath + "`)\n" +
			":floppy_disk: `fsck`: show disk space on :raspberry_pi:\n" +
			":baseball: `bb`: show yesterday's baseball games\n" +
			":youtube: `yt <video url>`: Download Youtube video to Papa's handy\n"
		api.PostMessage(slackMessage.Channel, response, params)
	} else {
		rtm.SendMessage(rtm.NewOutgoingMessage("whaddya say <@"+callingUserProfile.Name+">? Try `help` instead...",
			slackMessage.Channel))
	}
}

func mvvRoute(origin string, destination string) string {
	loc, _ := time.LoadLocation("Europe/Berlin")
	date := time.Now().In(loc)

	yearObj := date.Year()
	monthObj := int(date.Month())
	dayObj := date.Day()
	hourObj := date.Hour()
	minuteObj := date.Minute()

	month := strconv.Itoa(monthObj)
	hour := strconv.Itoa(hourObj)
	day := strconv.Itoa(dayObj)
	minute := strconv.Itoa(minuteObj)
	year := strconv.Itoa(yearObj)

	return "http://efa.mvv-muenchen.de/mvv/XSLT_TRIP_REQUEST2?&language=de" +
		"&anyObjFilter_origin=0&sessionID=0&itdTripDateTimeDepArr=dep&type_destination=any" +
		"&itdDateMonth=" + month + "&itdTimeHour=" + hour + "&anySigWhenPerfectNoOtherMatches=1" +
		"&locationServerActive=1&name_origin=" + origin + "&itdDateDay=" + day + "&type_origin=any" +
		"&name_destination=" + destination + "&itdTimeMinute=" + minute + "&Session=0&stateless=1" +
		"&SpEncId=0&itdDateYear=" + year
}

func downloadYoutubeVideo(origURL string) bool {
	resp, _ := http.Get("https://ackerson.de/bb_download?gameURL=" + origURL)
	if resp.StatusCode == 200 {
		return true
	}

	return false
}
